import inspect

from dataorientedai.core.interfaces.IAdapter import IAdapter
from dataorientedai.core.IoC import IoC
from dataorientedai.core.UObject import UObject


class Adapter(IAdapter):
    """Реализован генератор адаптеров"""

    @staticmethod
    def generate(InterfaceClass: object):
        class_name = InterfaceClass.__name__
        class_space = inspect.getmodule(InterfaceClass).__dict__
        class_module = InterfaceClass.__module__
        class_attrs_names = [
            m[0] for m in inspect.getmembers(InterfaceClass, inspect.isfunction)
        ]

        if class_name[:9] == "Interface" and class_name[9].isupper():
            adapter_class_name = class_name[9:]
        elif class_name[:1] == "I" and class_name[1].isupper():
            adapter_class_name = class_name[1:]
        else:
            adapter_class_name = class_name
        adapter_class_name = f"AutoGenerated{adapter_class_name}Adapter"

        class_definition = (
            f"class {adapter_class_name}({class_name}):\n"
            f"    def __init__(self, o: {UObject.__name__}):\n"
            "        self.o = o\n"
            "\n"
        )
        for attr_name in class_attrs_names:
            if attr_name[:4] == "get_":
                class_definition += (
                    f"    def {attr_name}(self):\n"
                    f"        return {IoC.__name__}.resolve(\n"
                    f'            "Interfaces.{class_name}:{attr_name[4:]}.get",\n'
                    "            self.o,\n"
                    "        )\n"
                    "\n"
                )
            elif attr_name[:4] == "set_":
                class_definition += (
                    f"    def {attr_name}(self, value):\n"
                    f"        return {IoC.__name__}.resolve(\n"
                    f'            "Interfaces.{class_name}:{attr_name[4:]}.set",\n'
                    "            self.o,\n"
                    "            value,\n"
                    "        )"
                    "\n"
                )
            else:
                # Необязательная задача на подумать:
                # если интерфейсе потребуются какие-либо иные методы
                # f'            "{class_module}.{class_name}:{attr_name}",\n'
                class_definition += (
                    f"    def {attr_name}(self, *args):\n"
                    "        return IoC.resolve(\n"
                    f'            "Interfaces.{class_name}:{attr_name}",\n'
                    "            *args,\n"
                    "        )\n"
                    "\n"
                )
        # class_space = inspect.getmodule(InterfaceClass).__dict__
        exec(class_definition, class_space)
        AdaptedClass = type(
            adapter_class_name,
            (InterfaceClass,),
            class_space[adapter_class_name].__dict__.copy(),
        )
        return AdaptedClass
        # print(class_definition)
        # exec(class_definition)
        # return locals()[adapter_class_name]


# # %%
# class MoveCmdPluginCmd(ICommand):
#     def execute(self):
#         IoC.resolve(
#             "IoC.register",
#             f"{IMovable.__module__}.IMovable:position.get",
#             lambda *args: args[0].get_property("position"),
#         ).execute()
#         IoC.resolve(
#             "IoC.register",
#             f"{IMovable.__module__}.IMovable:velocity.get",
#             lambda *args: args[0].get_property("velocity"),
#         ).execute()
#         IoC.resolve(
#             "IoC.register",
#             f"{IMovable.__module__}.IMovable:position.set",
#             lambda *args: args[0].set_property("position", args[1]),
#         ).execute()  # тут могло быть что-то сложное (вплоть до нейронок)


# class RotateCmdPluginCmd(ICommand):
#     def execute(self):
#         IoC.resolve(
#             "IoC.register",
#             f"{IRotable.__module__}.IRotable:direction.get",
#             lambda *args: args[0].get_property("direction"),
#         ).execute()
#         IoC.resolve(
#             "IoC.register",
#             f"{IRotable.__module__}.IRotable:direction_numbers.get",
#             lambda *args: args[0].get_property("direction_numbers"),
#         ).execute()
#         IoC.resolve(
#             "IoC.register",
#             f"{IRotable.__module__}.IRotable:angular_velocity.get",
#             lambda *args: args[0].get_property("angular_velocity"),
#         ).execute()
#         IoC.resolve(
#             "IoC.register",
#             f"{IRotable.__module__}.IRotable:direction.set",
#             lambda *args: args[0].set_property("direction", args[1]),
#         ).execute()

# if __name__ == "__main__":
#     # initialization
#     InitScopeBasedIoCImplementationCmd().execute()
#     current_scope = IoC.resolve(
#         "scopes.new",
#         IoC.resolve("scopes.root"),
#     )
#     IoC.resolve(
#         "scopes.current.set",
#         current_scope,
#     ).execute()
#     MoveCmdPluginCmd().execute()
#     RotateCmdPluginCmd().execute()

#     # Экземпляры генерируемых оберток для объекта obj можно создавать
#     # следующей строкой:
#     # var adapter = IoC.Resolve("Adapter", typeof(IMovable), obj);
#     IoC.resolve(
#         "IoC.register",
#         "Adapter",
#         lambda *args: Adapter.generate(args[0])(args[1]),
#     ).execute()

#     obj = UObject()
#     obj.set_property("position", Vector([12.0, 5.0]))
#     obj.set_property("velocity", Vector([-7.0, 3.0]))
#     obj.set_property("direction", 0)
#     obj.set_property("direction_numbers", 8)
#     obj.set_property("angular_velocity", -1)

#     movable_obj = IoC.resolve("Adapter", IMovable, obj)
#     print(movable_obj.get_position())
#     print(movable_obj.get_velocity())
#     movable_obj.set_position([111, 111])
#     movable_obj.set_position([222, 222])
#     print(movable_obj.get_position())
#     print(movable_obj.get_velocity())

#     print([m[0] for m in inspect.getmembers(movable_obj.__class__,
#                                             inspect.isfunction)])

#     rotable_obj = IoC.resolve("Adapter", IRotable, obj)
#     rotable_obj.set_direction(2)
#     print(rotable_obj.get_direction())
#     print([m[0] for m in inspect.getmembers(rotable_obj.__class__,
#                                             inspect.isfunction)])
